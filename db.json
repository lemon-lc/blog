{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1552912528000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1552912528000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1552912528000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1552912528000},{"_id":"source/CNAME","hash":"5fb2c67a1b125ec2b74c782208a194c914bc7670","modified":1552786124806},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1552912528000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1552912528000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1552912528000},{"_id":"themes/yilia/_config.yml","hash":"78b43a40115fdfe63b2d24c5eb101b292bb830b6","modified":1552912528000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1552912528000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1552912528000},{"_id":"source/_posts/理解JavaScript中的闭包.md","hash":"464bd4bb45309a4e3b1f4743f08338378d1faaed","modified":1552888096847},{"_id":"source/_posts/JavaScript函数的传参.md","hash":"99aa04770f4e97e27b73864336d831d857493570","modified":1552818827218},{"_id":"source/_posts/2019年给自己立点flag.md","hash":"5b785e34312d7f450065aea6127d042758bede55","modified":1552818893563},{"_id":"source/_posts/理解JavaScript作用域.md","hash":"0222ba6f11675bdb0bee6c90cca14889ae22e3f7","modified":1552875335019},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1552912528000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1552912528000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1552912528000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1552912528000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1552912528000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1552912528000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1552912528000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1552912528000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1552912528000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1552912528000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1552912528000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1552912528000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1552912528000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1552912528000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"a6ea4b252585215f86939542ed805886a58cf483","modified":1552912528000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1552912528000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1552912528000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552912528000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1552912528000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"f028c0bac935ab9d6304fe541cb62f0f570ab240","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"209459f4c1e081f79dfd2ce71fb1f84735ea696c","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"ae184fc860aa8ed2c304e14b45380472c891e824","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7025a4f471281eabb473046646b15cfa950ced2e","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1552912528000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1552912528000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1552912528000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1552912528000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1552912528000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1552912528000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1552912528000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1552912528000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1552912528000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1552912528000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1552912528000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1552912528000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1552912528000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1552912528000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1552912528000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1552912528000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1552912528000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1552912528000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1552912528000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1552912528000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1552912528000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1552912528000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"01219574c7f3be225f9468700ca1c2dc3e65e1bc","modified":1552912528000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1552912528000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1552912528000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1552912528000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1552912528000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"8a1e0bd09d44ab7b040b540bd7e1391ab5198788","modified":1552912528000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1552912528000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1552912528000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1552912528000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1552912528000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1552912528000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1552912528000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1552912528000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1552912528000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1552912528000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1552912528000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1552912528000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1552912528000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1552912528000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1552912528000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1552912528000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1552912528000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1552912528000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1552912528000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1552912528000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1552912528000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1552912528000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1552912528000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1552912528000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1552912528000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1552912528000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1552912528000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1552912528000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1552912528000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1552912528000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1552912528000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1552912528000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1552912528000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1552912528000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1552912528000},{"_id":"public/content.json","hash":"1b01dffaa22f136896a42915fec49bc85f8f36bd","modified":1552990058427},{"_id":"public/2019/02/17/理解JavaScript中的闭包/index.html","hash":"97997e3fd6d823db7778516729adc6887e12f6cf","modified":1552990058874},{"_id":"public/2019/01/27/2019年给自己立点flag/index.html","hash":"c21fc853e268d191b08022f735edf302b0dbfc5e","modified":1552990058875},{"_id":"public/2019/01/16/JavaScript函数的传参/index.html","hash":"c61b3ee7af7c50c1bcb61d8311aa77ccf5ed0306","modified":1552990058875},{"_id":"public/2018/12/20/理解JavaScript作用域/index.html","hash":"d66e30cc49f1a15e2c011bad158630f5511b0ba1","modified":1552990058875},{"_id":"public/archives/2018/index.html","hash":"fd905dcd1539991275f7c25e08083e7434c738d7","modified":1552990058875},{"_id":"public/archives/index.html","hash":"0a4531d9f94d86f053a1798ccc59e50837893eb5","modified":1552990058875},{"_id":"public/archives/2018/12/index.html","hash":"f66f4d1729e47846acca0a93aa15c6a85d658853","modified":1552990058875},{"_id":"public/archives/2019/index.html","hash":"abff0c1d00ddf6aaee64947034748289bf451c5d","modified":1552990058875},{"_id":"public/archives/2019/01/index.html","hash":"30aa8a8acc3efdd6ca55dde6272860ef6104d1f0","modified":1552990058875},{"_id":"public/archives/2019/02/index.html","hash":"d6a6043a42f2729055b33439c48b78a3f1973fe7","modified":1552990058876},{"_id":"public/index.html","hash":"cb960d46fdca468c6b704428759028084b9a191f","modified":1552990058876},{"_id":"public/tags/深入学习JS/index.html","hash":"f663cda19dceb17aee34d63f16805b30a20d395c","modified":1552990058876},{"_id":"public/tags/随笔/index.html","hash":"7449e51c42a2929a202f7dd0fcfd4af31210b15f","modified":1552990058876},{"_id":"public/CNAME","hash":"5fb2c67a1b125ec2b74c782208a194c914bc7670","modified":1552990058878},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1552990058878},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1552990058878},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1552990058878},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1552990058879},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1552990058879},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1552990058879},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1552990058879},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1552990058879},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1552990058879},{"_id":"public/main.0cf68a.css","hash":"a6ea4b252585215f86939542ed805886a58cf483","modified":1552990058883},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1552990058883},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1552990058883},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1552990058883}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"理解JavaScript中的闭包","date":"2019-02-16T16:00:00.000Z","_content":"\n#### 什么是闭包\n> 闭包是指有权访问另一个函数作用域中的变量的函数。\n\n闭包不是我们需要学习的语法或者模式才能使用的工具，闭包是基于词法作用域书写代码是所产生的自然结果，闭包在我们所写的代码中随处可见。\n<!-- more -->\n#### 闭包的产生\n> 当函数可以记住并访问所在的词法作用域是，就产生了闭包，即使函数是在当前词法作用域之外执行。\n\n根据闭包的定义其实创建闭包最常用的方式就是在一个函数内部创建另外一个函数：\n\n```javascript\nfunction fn() {\n    var str = 'fn';\n    function innerFn() {\n        console.log(str)\n    }\n    return innerFn;\n}\n\nvar spoce = fn();\nspoce() // 'fn'\n```\n函数 innerFn 能过访问 fn 的内部作用域，fn 函数将 innerFn 所引用的函数对象作为一个返回值传递出去。\nfn 函数执行后，spoce 获取 innerFn 引用的函数对象，执行 spoce 就会打印出 'fn' , 通常一个函数被执行其整个内部作用域都会被销毁，然而 fn 的内部作用域仍然存在, 并且 spoce 可以在 fn 内部作用域之外访问到 fn 函数内部的变量。\n其实这一切都是因为 innerFn 函数拥有覆盖 fn 函数内部作用域的闭包，使得该作用域能够一直存货，以供 innerFn 在之后的任何时间进行引用。\ninnerFn 函数对 fn 函数内部作用域的持续引用就叫做闭包。\n\n#### 闭包的应用\n> JavaScript中闭包无处不在。\n设计模式 单例\nfor循环 闭包\n#### 总结\n","source":"_posts/理解JavaScript中的闭包.md","raw":"---\ntitle: 理解JavaScript中的闭包\ntag: 深入学习JS\ndate: 2019-02-17\n---\n\n#### 什么是闭包\n> 闭包是指有权访问另一个函数作用域中的变量的函数。\n\n闭包不是我们需要学习的语法或者模式才能使用的工具，闭包是基于词法作用域书写代码是所产生的自然结果，闭包在我们所写的代码中随处可见。\n<!-- more -->\n#### 闭包的产生\n> 当函数可以记住并访问所在的词法作用域是，就产生了闭包，即使函数是在当前词法作用域之外执行。\n\n根据闭包的定义其实创建闭包最常用的方式就是在一个函数内部创建另外一个函数：\n\n```javascript\nfunction fn() {\n    var str = 'fn';\n    function innerFn() {\n        console.log(str)\n    }\n    return innerFn;\n}\n\nvar spoce = fn();\nspoce() // 'fn'\n```\n函数 innerFn 能过访问 fn 的内部作用域，fn 函数将 innerFn 所引用的函数对象作为一个返回值传递出去。\nfn 函数执行后，spoce 获取 innerFn 引用的函数对象，执行 spoce 就会打印出 'fn' , 通常一个函数被执行其整个内部作用域都会被销毁，然而 fn 的内部作用域仍然存在, 并且 spoce 可以在 fn 内部作用域之外访问到 fn 函数内部的变量。\n其实这一切都是因为 innerFn 函数拥有覆盖 fn 函数内部作用域的闭包，使得该作用域能够一直存货，以供 innerFn 在之后的任何时间进行引用。\ninnerFn 函数对 fn 函数内部作用域的持续引用就叫做闭包。\n\n#### 闭包的应用\n> JavaScript中闭包无处不在。\n设计模式 单例\nfor循环 闭包\n#### 总结\n","slug":"理解JavaScript中的闭包","published":1,"updated":"2019-03-18T05:48:16.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtfm6lt70000ffx16h9cum2r","content":"<h4 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h4><blockquote>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n</blockquote>\n<p>闭包不是我们需要学习的语法或者模式才能使用的工具，闭包是基于词法作用域书写代码是所产生的自然结果，闭包在我们所写的代码中随处可见。<br><a id=\"more\"></a></p>\n<h4 id=\"闭包的产生\"><a href=\"#闭包的产生\" class=\"headerlink\" title=\"闭包的产生\"></a>闭包的产生</h4><blockquote>\n<p>当函数可以记住并访问所在的词法作用域是，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>\n</blockquote>\n<p>根据闭包的定义其实创建闭包最常用的方式就是在一个函数内部创建另外一个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'fn'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">innerFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> innerFn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spoce = fn();</span><br><span class=\"line\">spoce() <span class=\"comment\">// 'fn'</span></span><br></pre></td></tr></table></figure>\n<p>函数 innerFn 能过访问 fn 的内部作用域，fn 函数将 innerFn 所引用的函数对象作为一个返回值传递出去。<br>fn 函数执行后，spoce 获取 innerFn 引用的函数对象，执行 spoce 就会打印出 ‘fn’ , 通常一个函数被执行其整个内部作用域都会被销毁，然而 fn 的内部作用域仍然存在, 并且 spoce 可以在 fn 内部作用域之外访问到 fn 函数内部的变量。<br>其实这一切都是因为 innerFn 函数拥有覆盖 fn 函数内部作用域的闭包，使得该作用域能够一直存货，以供 innerFn 在之后的任何时间进行引用。<br>innerFn 函数对 fn 函数内部作用域的持续引用就叫做闭包。</p>\n<h4 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h4><blockquote>\n<p>JavaScript中闭包无处不在。<br>设计模式 单例<br>for循环 闭包</p>\n</blockquote>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4>","site":{"data":{}},"excerpt":"<h4 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h4><blockquote>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n</blockquote>\n<p>闭包不是我们需要学习的语法或者模式才能使用的工具，闭包是基于词法作用域书写代码是所产生的自然结果，闭包在我们所写的代码中随处可见。<br>","more":"</p>\n<h4 id=\"闭包的产生\"><a href=\"#闭包的产生\" class=\"headerlink\" title=\"闭包的产生\"></a>闭包的产生</h4><blockquote>\n<p>当函数可以记住并访问所在的词法作用域是，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>\n</blockquote>\n<p>根据闭包的定义其实创建闭包最常用的方式就是在一个函数内部创建另外一个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'fn'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">innerFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> innerFn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spoce = fn();</span><br><span class=\"line\">spoce() <span class=\"comment\">// 'fn'</span></span><br></pre></td></tr></table></figure>\n<p>函数 innerFn 能过访问 fn 的内部作用域，fn 函数将 innerFn 所引用的函数对象作为一个返回值传递出去。<br>fn 函数执行后，spoce 获取 innerFn 引用的函数对象，执行 spoce 就会打印出 ‘fn’ , 通常一个函数被执行其整个内部作用域都会被销毁，然而 fn 的内部作用域仍然存在, 并且 spoce 可以在 fn 内部作用域之外访问到 fn 函数内部的变量。<br>其实这一切都是因为 innerFn 函数拥有覆盖 fn 函数内部作用域的闭包，使得该作用域能够一直存货，以供 innerFn 在之后的任何时间进行引用。<br>innerFn 函数对 fn 函数内部作用域的持续引用就叫做闭包。</p>\n<h4 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h4><blockquote>\n<p>JavaScript中闭包无处不在。<br>设计模式 单例<br>for循环 闭包</p>\n</blockquote>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4>"},{"title":"JavaScript函数的传参","date":"2019-01-15T16:00:00.000Z","_content":"JavaScript 中的函数传参是按值传递还是按引用传递呢？\n> ECMAScript 中所有函数的参数都是按值传递的。\n<p align=\"right\"><font color=gray size=2>摘自 JavaScript高级程序设计</font></p>\n\n<!-- more -->\n\n下面我们看一段代码\n```javascript\nfunction changeStuff(a, b, c) {\n  a = a * 10;\n  b.item = \"changed\";\n  c = {item: \"changed\"};\n}\n\nvar num = 10;\nvar obj1 = {item: \"unchanged\"};\nvar obj2 = {item: \"unchanged\"};\n\nchangeStuff(num, obj1, obj2);\n\nconsole.log('num: 'num);\nconsole.log('obj1: 'obj1.item);\nconsole.log('obj2: 'obj2.item);\n```\n打印出来的值是：\n```javascript\nnum: 10\nobj1: {item: \"changed\"}\nobj2: {item: \"unchanged\"}\n```\n说好的按值传递为什么 obj1 的值变了。\n<div align=center>\n<img width = \"150\" height = \"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/9150e4e5ly1fl77kzjvr5g208c08caa4.gif\"/>\n</div>\n\n在继续了解 JavaScript 的函数是怎么传参之前，先简单了解一下 JavaScript 中是数据类型。\n### 数据类型\nJS中有7种数据类型，6种基本数据类型（Undefined, Null, Boolean, Number, String, Symbol）和一种复杂数据类型(Object)。\n\n> 除 Object 以外的所有类型都是不可变的（值本身无法被改变）。\n\n\n#### 基本数据类型\n基本数据类型就是数字、字符串、布尔值、还有两个比较特殊的 null 和 undefined，以及 ES6 新增的 symbol 。\n1. 基本数据类型的值是按值访问的；\n2. 基本类型的值是不可变的；\n3. 基本数据类型比较是按值进行比较。\n\n#### 引用数据类型\n除了上面的六种数据类型之外，其他的都是引用类型，统称为 Object 类型，主要细分为Object、Array、Date、RegExpd等。\n\n1. 基本数据类型的值是按引用访问的；\n2. 引用数据类型是可变的；\n3. 引用数据类型是按引用访问的。\n\n下面我们来看一段代码：\n```javascript\nvar obj1 = {name: \"hello world\"};\nvar obj2 = {name: \"hello world\"};\nvar obj3 = obj1;\nconsole.log(obj1 === obj2); // 1\nconsole.log(obj1 === obj3); // 2\nobj3.name = \"hello javascript\";\nconsole.log(obj1.name); // 3\n```\n<div align=center>\n<img height = \"250\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-221856%402x.png\"/>\n</div>\n\nobj1 和 obj2 指向的是不同内存地址，obj1 和 obj3 指向的是同一个内存地址。\n\n所以第一个打印的结果应该是 false ，obj1 和 obj2 的引用地址不同，第二个打印结果为 true，obj1 和 obj3 的引用地址相同。 第三个打印结果为 'hello javascript'， 修改 obj3 其实就是修改了其指向的对象的值，所以 obj1 也发生了变化。\n\n### 函数的传参\n下面我们再来看看执行了 changeStuff 之后发生了什么吧。\n\n<div align=center>\n<img height = \"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/1548554750178.jpg\"/>\n</div>\n\nchangeStuff 执行之后就是对 changeStuff 中的三个形参进行了一次赋值操作，相当于：\n```javascript\na = num;\nb = obj1;\nc = obj2;\n```\n<div align=center>\n<img height = \"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200153%402x.png\"/>\n</div>\nnum 是基础类型，所以 a 指向的是一个新的内存地址，而 obj1 和 obj2 是引用类型，赋值给 a, b 的值是当前的引用地址。所以 a, b 指向的是 obj1 和 obj2 指向的内存地址。\n```\na = a * 10;\nb.item = \"changed\";\nc = {item: \"changed\"};\n```\n这段代码执行完之后，会重新给 a 指向一个新的内存地址，==b.item = 'changed'== 实际上就是修改 b 所指向对象的 item 的值， ==c = {item: \"changed\"}== 把 c 指向一个新的内存地址，切断了 c 与 obj2 之间的联系。\n<div align=center>\n<img height = \"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200614%402x.png\"/>\n</div>\n所以打印的值是\n```javascript\nnum: 10\nobj1: {item: \"changed\"}\nobj2: {item: \"unchanged\"}\n```\n#### 传入参数声明的位置\n在 JS 中我们都知道使用 var 和 function 声明一个变量时会存在变量提升，但是当同时使用 var、function 声明一个变量 'a' 以及传入一个同名变量 'a' 时，最后 JS引擎 会把哪个值赋给变量 'a' 呢 ？\n\n```javascript\n(function (a) {\n    var a = 10;\n    console.log(1, a);\n})(20);\n(function () {\n    var a = 10;\n    console.log(2, a);\n    function a() {};\n})();\n(function (a) {\n    console.log(3, a);\n    function a() {};\n})(20);\n```\n你可以复制这段代码到浏览器的控制台中看一下执行结果，下面是执行结果：\n```javascript\n1 10\n2 10\n3 ƒ a() {}\n```\n由此三段代码可以看出来：\n\n传入的参数是相当于声明在函数的最顶部，还在提升的函数之前。（后声明的变量的值覆盖了前面的值）\n### 总结\nECMAScript 中所有函数的参数都是按值传递的，对于引用类型的值传递的是当前对象的引用，即一个堆内存的地址。\n","source":"_posts/JavaScript函数的传参.md","raw":"---\ntitle: JavaScript函数的传参\ntag: 深入学习JS\ndate: 2019-01-16\n---\nJavaScript 中的函数传参是按值传递还是按引用传递呢？\n> ECMAScript 中所有函数的参数都是按值传递的。\n<p align=\"right\"><font color=gray size=2>摘自 JavaScript高级程序设计</font></p>\n\n<!-- more -->\n\n下面我们看一段代码\n```javascript\nfunction changeStuff(a, b, c) {\n  a = a * 10;\n  b.item = \"changed\";\n  c = {item: \"changed\"};\n}\n\nvar num = 10;\nvar obj1 = {item: \"unchanged\"};\nvar obj2 = {item: \"unchanged\"};\n\nchangeStuff(num, obj1, obj2);\n\nconsole.log('num: 'num);\nconsole.log('obj1: 'obj1.item);\nconsole.log('obj2: 'obj2.item);\n```\n打印出来的值是：\n```javascript\nnum: 10\nobj1: {item: \"changed\"}\nobj2: {item: \"unchanged\"}\n```\n说好的按值传递为什么 obj1 的值变了。\n<div align=center>\n<img width = \"150\" height = \"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/9150e4e5ly1fl77kzjvr5g208c08caa4.gif\"/>\n</div>\n\n在继续了解 JavaScript 的函数是怎么传参之前，先简单了解一下 JavaScript 中是数据类型。\n### 数据类型\nJS中有7种数据类型，6种基本数据类型（Undefined, Null, Boolean, Number, String, Symbol）和一种复杂数据类型(Object)。\n\n> 除 Object 以外的所有类型都是不可变的（值本身无法被改变）。\n\n\n#### 基本数据类型\n基本数据类型就是数字、字符串、布尔值、还有两个比较特殊的 null 和 undefined，以及 ES6 新增的 symbol 。\n1. 基本数据类型的值是按值访问的；\n2. 基本类型的值是不可变的；\n3. 基本数据类型比较是按值进行比较。\n\n#### 引用数据类型\n除了上面的六种数据类型之外，其他的都是引用类型，统称为 Object 类型，主要细分为Object、Array、Date、RegExpd等。\n\n1. 基本数据类型的值是按引用访问的；\n2. 引用数据类型是可变的；\n3. 引用数据类型是按引用访问的。\n\n下面我们来看一段代码：\n```javascript\nvar obj1 = {name: \"hello world\"};\nvar obj2 = {name: \"hello world\"};\nvar obj3 = obj1;\nconsole.log(obj1 === obj2); // 1\nconsole.log(obj1 === obj3); // 2\nobj3.name = \"hello javascript\";\nconsole.log(obj1.name); // 3\n```\n<div align=center>\n<img height = \"250\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-221856%402x.png\"/>\n</div>\n\nobj1 和 obj2 指向的是不同内存地址，obj1 和 obj3 指向的是同一个内存地址。\n\n所以第一个打印的结果应该是 false ，obj1 和 obj2 的引用地址不同，第二个打印结果为 true，obj1 和 obj3 的引用地址相同。 第三个打印结果为 'hello javascript'， 修改 obj3 其实就是修改了其指向的对象的值，所以 obj1 也发生了变化。\n\n### 函数的传参\n下面我们再来看看执行了 changeStuff 之后发生了什么吧。\n\n<div align=center>\n<img height = \"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/1548554750178.jpg\"/>\n</div>\n\nchangeStuff 执行之后就是对 changeStuff 中的三个形参进行了一次赋值操作，相当于：\n```javascript\na = num;\nb = obj1;\nc = obj2;\n```\n<div align=center>\n<img height = \"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200153%402x.png\"/>\n</div>\nnum 是基础类型，所以 a 指向的是一个新的内存地址，而 obj1 和 obj2 是引用类型，赋值给 a, b 的值是当前的引用地址。所以 a, b 指向的是 obj1 和 obj2 指向的内存地址。\n```\na = a * 10;\nb.item = \"changed\";\nc = {item: \"changed\"};\n```\n这段代码执行完之后，会重新给 a 指向一个新的内存地址，==b.item = 'changed'== 实际上就是修改 b 所指向对象的 item 的值， ==c = {item: \"changed\"}== 把 c 指向一个新的内存地址，切断了 c 与 obj2 之间的联系。\n<div align=center>\n<img height = \"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200614%402x.png\"/>\n</div>\n所以打印的值是\n```javascript\nnum: 10\nobj1: {item: \"changed\"}\nobj2: {item: \"unchanged\"}\n```\n#### 传入参数声明的位置\n在 JS 中我们都知道使用 var 和 function 声明一个变量时会存在变量提升，但是当同时使用 var、function 声明一个变量 'a' 以及传入一个同名变量 'a' 时，最后 JS引擎 会把哪个值赋给变量 'a' 呢 ？\n\n```javascript\n(function (a) {\n    var a = 10;\n    console.log(1, a);\n})(20);\n(function () {\n    var a = 10;\n    console.log(2, a);\n    function a() {};\n})();\n(function (a) {\n    console.log(3, a);\n    function a() {};\n})(20);\n```\n你可以复制这段代码到浏览器的控制台中看一下执行结果，下面是执行结果：\n```javascript\n1 10\n2 10\n3 ƒ a() {}\n```\n由此三段代码可以看出来：\n\n传入的参数是相当于声明在函数的最顶部，还在提升的函数之前。（后声明的变量的值覆盖了前面的值）\n### 总结\nECMAScript 中所有函数的参数都是按值传递的，对于引用类型的值传递的是当前对象的引用，即一个堆内存的地址。\n","slug":"JavaScript函数的传参","published":1,"updated":"2019-03-17T10:33:47.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtfm6ltb0001ffx1v4oxnbz7","content":"<p>JavaScript 中的函数传参是按值传递还是按引用传递呢？</p>\n<blockquote>\n<p>ECMAScript 中所有函数的参数都是按值传递的。</p>\n</blockquote>\n<p align=\"right\"><font color=\"gray\" size=\"2\">摘自 JavaScript高级程序设计</font></p>\n\n<a id=\"more\"></a>\n<p>下面我们看一段代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeStuff</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  a = a * <span class=\"number\">10</span>;</span><br><span class=\"line\">  b.item = <span class=\"string\">\"changed\"</span>;</span><br><span class=\"line\">  c = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"changed\"</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">changeStuff(num, obj1, obj2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'num: '</span>num);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'obj1: '</span>obj1.item);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'obj2: '</span>obj2.item);</span><br></pre></td></tr></table></figure></p>\n<p>打印出来的值是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num: <span class=\"number\">10</span></span><br><span class=\"line\">obj1: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"changed\"</span>&#125;</span><br><span class=\"line\">obj2: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>说好的按值传递为什么 obj1 的值变了。</p>\n<div align=\"center\"><br><img width=\"150\" height=\"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/9150e4e5ly1fl77kzjvr5g208c08caa4.gif\"><br></div>\n\n<p>在继续了解 JavaScript 的函数是怎么传参之前，先简单了解一下 JavaScript 中是数据类型。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>JS中有7种数据类型，6种基本数据类型（Undefined, Null, Boolean, Number, String, Symbol）和一种复杂数据类型(Object)。</p>\n<blockquote>\n<p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。</p>\n</blockquote>\n<h4 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h4><p>基本数据类型就是数字、字符串、布尔值、还有两个比较特殊的 null 和 undefined，以及 ES6 新增的 symbol 。</p>\n<ol>\n<li>基本数据类型的值是按值访问的；</li>\n<li>基本类型的值是不可变的；</li>\n<li>基本数据类型比较是按值进行比较。</li>\n</ol>\n<h4 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h4><p>除了上面的六种数据类型之外，其他的都是引用类型，统称为 Object 类型，主要细分为Object、Array、Date、RegExpd等。</p>\n<ol>\n<li>基本数据类型的值是按引用访问的；</li>\n<li>引用数据类型是可变的；</li>\n<li>引用数据类型是按引用访问的。</li>\n</ol>\n<p>下面我们来看一段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"hello world\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"hello world\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj3 = obj1;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 === obj2); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 === obj3); <span class=\"comment\">// 2</span></span><br><span class=\"line\">obj3.name = <span class=\"string\">\"hello javascript\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.name); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<div align=\"center\"><br><img height=\"250\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-221856%402x.png\"><br></div>\n\n<p>obj1 和 obj2 指向的是不同内存地址，obj1 和 obj3 指向的是同一个内存地址。</p>\n<p>所以第一个打印的结果应该是 false ，obj1 和 obj2 的引用地址不同，第二个打印结果为 true，obj1 和 obj3 的引用地址相同。 第三个打印结果为 ‘hello javascript’， 修改 obj3 其实就是修改了其指向的对象的值，所以 obj1 也发生了变化。</p>\n<h3 id=\"函数的传参\"><a href=\"#函数的传参\" class=\"headerlink\" title=\"函数的传参\"></a>函数的传参</h3><p>下面我们再来看看执行了 changeStuff 之后发生了什么吧。</p>\n<div align=\"center\"><br><img height=\"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/1548554750178.jpg\"><br></div>\n\n<p>changeStuff 执行之后就是对 changeStuff 中的三个形参进行了一次赋值操作，相当于：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = num;</span><br><span class=\"line\">b = obj1;</span><br><span class=\"line\">c = obj2;</span><br></pre></td></tr></table></figure></p>\n<p><div align=\"center\"><br><img height=\"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200153%402x.png\"><br></div><br>num 是基础类型，所以 a 指向的是一个新的内存地址，而 obj1 和 obj2 是引用类型，赋值给 a, b 的值是当前的引用地址。所以 a, b 指向的是 obj1 和 obj2 指向的内存地址。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a * 10;</span><br><span class=\"line\">b.item = &quot;changed&quot;;</span><br><span class=\"line\">c = &#123;item: &quot;changed&quot;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码执行完之后，会重新给 a 指向一个新的内存地址，==b.item = ‘changed’== 实际上就是修改 b 所指向对象的 item 的值， ==c = {item: “changed”}== 把 c 指向一个新的内存地址，切断了 c 与 obj2 之间的联系。</p>\n<p><div align=\"center\"><br><img height=\"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200614%402x.png\"><br></div><br>所以打印的值是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num: <span class=\"number\">10</span></span><br><span class=\"line\">obj1: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"changed\"</span>&#125;</span><br><span class=\"line\">obj2: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"传入参数声明的位置\"><a href=\"#传入参数声明的位置\" class=\"headerlink\" title=\"传入参数声明的位置\"></a>传入参数声明的位置</h4><p>在 JS 中我们都知道使用 var 和 function 声明一个变量时会存在变量提升，但是当同时使用 var、function 声明一个变量 ‘a’ 以及传入一个同名变量 ‘a’ 时，最后 JS引擎 会把哪个值赋给变量 ‘a’ 呢 ？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, a);</span><br><span class=\"line\">&#125;)(<span class=\"number\">20</span>);</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, a);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, a);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;)(<span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<p>你可以复制这段代码到浏览器的控制台中看一下执行结果，下面是执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">3</span> ƒ a() &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此三段代码可以看出来：</p>\n<p>传入的参数是相当于声明在函数的最顶部，还在提升的函数之前。（后声明的变量的值覆盖了前面的值）</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ECMAScript 中所有函数的参数都是按值传递的，对于引用类型的值传递的是当前对象的引用，即一个堆内存的地址。</p>\n","site":{"data":{}},"excerpt":"<p>JavaScript 中的函数传参是按值传递还是按引用传递呢？</p>\n<blockquote>\n<p>ECMAScript 中所有函数的参数都是按值传递的。</p>\n</blockquote>\n<p align=\"right\"><font color=\"gray\" size=\"2\">摘自 JavaScript高级程序设计</font></p>","more":"<p>下面我们看一段代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeStuff</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  a = a * <span class=\"number\">10</span>;</span><br><span class=\"line\">  b.item = <span class=\"string\">\"changed\"</span>;</span><br><span class=\"line\">  c = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"changed\"</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">changeStuff(num, obj1, obj2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'num: '</span>num);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'obj1: '</span>obj1.item);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'obj2: '</span>obj2.item);</span><br></pre></td></tr></table></figure></p>\n<p>打印出来的值是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num: <span class=\"number\">10</span></span><br><span class=\"line\">obj1: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"changed\"</span>&#125;</span><br><span class=\"line\">obj2: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>说好的按值传递为什么 obj1 的值变了。</p>\n<div align=\"center\"><br><img width=\"150\" height=\"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/9150e4e5ly1fl77kzjvr5g208c08caa4.gif\"><br></div>\n\n<p>在继续了解 JavaScript 的函数是怎么传参之前，先简单了解一下 JavaScript 中是数据类型。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>JS中有7种数据类型，6种基本数据类型（Undefined, Null, Boolean, Number, String, Symbol）和一种复杂数据类型(Object)。</p>\n<blockquote>\n<p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。</p>\n</blockquote>\n<h4 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h4><p>基本数据类型就是数字、字符串、布尔值、还有两个比较特殊的 null 和 undefined，以及 ES6 新增的 symbol 。</p>\n<ol>\n<li>基本数据类型的值是按值访问的；</li>\n<li>基本类型的值是不可变的；</li>\n<li>基本数据类型比较是按值进行比较。</li>\n</ol>\n<h4 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h4><p>除了上面的六种数据类型之外，其他的都是引用类型，统称为 Object 类型，主要细分为Object、Array、Date、RegExpd等。</p>\n<ol>\n<li>基本数据类型的值是按引用访问的；</li>\n<li>引用数据类型是可变的；</li>\n<li>引用数据类型是按引用访问的。</li>\n</ol>\n<p>下面我们来看一段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"hello world\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"hello world\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj3 = obj1;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 === obj2); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 === obj3); <span class=\"comment\">// 2</span></span><br><span class=\"line\">obj3.name = <span class=\"string\">\"hello javascript\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.name); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<div align=\"center\"><br><img height=\"250\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-221856%402x.png\"><br></div>\n\n<p>obj1 和 obj2 指向的是不同内存地址，obj1 和 obj3 指向的是同一个内存地址。</p>\n<p>所以第一个打印的结果应该是 false ，obj1 和 obj2 的引用地址不同，第二个打印结果为 true，obj1 和 obj3 的引用地址相同。 第三个打印结果为 ‘hello javascript’， 修改 obj3 其实就是修改了其指向的对象的值，所以 obj1 也发生了变化。</p>\n<h3 id=\"函数的传参\"><a href=\"#函数的传参\" class=\"headerlink\" title=\"函数的传参\"></a>函数的传参</h3><p>下面我们再来看看执行了 changeStuff 之后发生了什么吧。</p>\n<div align=\"center\"><br><img height=\"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/1548554750178.jpg\"><br></div>\n\n<p>changeStuff 执行之后就是对 changeStuff 中的三个形参进行了一次赋值操作，相当于：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = num;</span><br><span class=\"line\">b = obj1;</span><br><span class=\"line\">c = obj2;</span><br></pre></td></tr></table></figure></p>\n<p><div align=\"center\"><br><img height=\"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200153%402x.png\"><br></div><br>num 是基础类型，所以 a 指向的是一个新的内存地址，而 obj1 和 obj2 是引用类型，赋值给 a, b 的值是当前的引用地址。所以 a, b 指向的是 obj1 和 obj2 指向的内存地址。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a * 10;</span><br><span class=\"line\">b.item = &quot;changed&quot;;</span><br><span class=\"line\">c = &#123;item: &quot;changed&quot;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码执行完之后，会重新给 a 指向一个新的内存地址，==b.item = ‘changed’== 实际上就是修改 b 所指向对象的 item 的值， ==c = {item: “changed”}== 把 c 指向一个新的内存地址，切断了 c 与 obj2 之间的联系。</p>\n<p><div align=\"center\"><br><img height=\"350\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/WX20190127-200614%402x.png\"><br></div><br>所以打印的值是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num: <span class=\"number\">10</span></span><br><span class=\"line\">obj1: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"changed\"</span>&#125;</span><br><span class=\"line\">obj2: &#123;<span class=\"attr\">item</span>: <span class=\"string\">\"unchanged\"</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"传入参数声明的位置\"><a href=\"#传入参数声明的位置\" class=\"headerlink\" title=\"传入参数声明的位置\"></a>传入参数声明的位置</h4><p>在 JS 中我们都知道使用 var 和 function 声明一个变量时会存在变量提升，但是当同时使用 var、function 声明一个变量 ‘a’ 以及传入一个同名变量 ‘a’ 时，最后 JS引擎 会把哪个值赋给变量 ‘a’ 呢 ？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, a);</span><br><span class=\"line\">&#125;)(<span class=\"number\">20</span>);</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, a);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, a);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;)(<span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<p>你可以复制这段代码到浏览器的控制台中看一下执行结果，下面是执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">3</span> ƒ a() &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此三段代码可以看出来：</p>\n<p>传入的参数是相当于声明在函数的最顶部，还在提升的函数之前。（后声明的变量的值覆盖了前面的值）</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ECMAScript 中所有函数的参数都是按值传递的，对于引用类型的值传递的是当前对象的引用，即一个堆内存的地址。</p>"},{"title":"2019年给自己立点flag","date":"2019-01-26T16:00:00.000Z","_content":"时光荏苒...(此处略去一万字)\n<!-- more -->\n时间过的有点快啊，转眼间2019年的第一个月就要结束了，马上就要回家过年了，可能有的同学已经回家或者在回家的路上了，而我还要去苦逼的上班。\n\n#### 新年新气象\n去年没有给自己制定目标一切都是随遇而安，今年就给自己制定几个目标，到年底检查一下自己能完成多少。\n\n- [ ] 每月更新一篇博客\n- [ ] 读完 你不知道的 JavaScript 全集\n- [ ] 读完 JavaScript设计模式与开发实践\n- [ ] 编写一个 TypeScript  的实战项目\n- [ ] 学习一遍 Redux 源码\n- [ ] 学习一遍 React-Router 源码\n- [ ] 学习一遍 React 源码\n- [ ] 两个月读完一本小说\n\n暂时就定这么多吧，年底回来检查成果。\n\n#### 结果检查\n##### 每月更新一篇博客\n- 1月份博客：[JavaScript函数的传参方式](https://github.com/volcanoliuc/blog/issues/2)\n\n##### 两个月读完一本小说","source":"_posts/2019年给自己立点flag.md","raw":"---\ntitle: 2019年给自己立点flag\ntag: 随笔\ndate: 2019-01-27\n---\n时光荏苒...(此处略去一万字)\n<!-- more -->\n时间过的有点快啊，转眼间2019年的第一个月就要结束了，马上就要回家过年了，可能有的同学已经回家或者在回家的路上了，而我还要去苦逼的上班。\n\n#### 新年新气象\n去年没有给自己制定目标一切都是随遇而安，今年就给自己制定几个目标，到年底检查一下自己能完成多少。\n\n- [ ] 每月更新一篇博客\n- [ ] 读完 你不知道的 JavaScript 全集\n- [ ] 读完 JavaScript设计模式与开发实践\n- [ ] 编写一个 TypeScript  的实战项目\n- [ ] 学习一遍 Redux 源码\n- [ ] 学习一遍 React-Router 源码\n- [ ] 学习一遍 React 源码\n- [ ] 两个月读完一本小说\n\n暂时就定这么多吧，年底回来检查成果。\n\n#### 结果检查\n##### 每月更新一篇博客\n- 1月份博客：[JavaScript函数的传参方式](https://github.com/volcanoliuc/blog/issues/2)\n\n##### 两个月读完一本小说","slug":"2019年给自己立点flag","published":1,"updated":"2019-03-17T10:34:53.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtfm6lte0003ffx1857o1nr3","content":"<p>时光荏苒…(此处略去一万字)<br><a id=\"more\"></a><br>时间过的有点快啊，转眼间2019年的第一个月就要结束了，马上就要回家过年了，可能有的同学已经回家或者在回家的路上了，而我还要去苦逼的上班。</p>\n<h4 id=\"新年新气象\"><a href=\"#新年新气象\" class=\"headerlink\" title=\"新年新气象\"></a>新年新气象</h4><p>去年没有给自己制定目标一切都是随遇而安，今年就给自己制定几个目标，到年底检查一下自己能完成多少。</p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 每月更新一篇博客</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 读完 你不知道的 JavaScript 全集</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 读完 JavaScript设计模式与开发实践</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 编写一个 TypeScript  的实战项目</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习一遍 Redux 源码</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习一遍 React-Router 源码</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习一遍 React 源码</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 两个月读完一本小说</li>\n</ul>\n<p>暂时就定这么多吧，年底回来检查成果。</p>\n<h4 id=\"结果检查\"><a href=\"#结果检查\" class=\"headerlink\" title=\"结果检查\"></a>结果检查</h4><h5 id=\"每月更新一篇博客\"><a href=\"#每月更新一篇博客\" class=\"headerlink\" title=\"每月更新一篇博客\"></a>每月更新一篇博客</h5><ul>\n<li>1月份博客：<a href=\"https://github.com/volcanoliuc/blog/issues/2\" target=\"_blank\" rel=\"noopener\">JavaScript函数的传参方式</a></li>\n</ul>\n<h5 id=\"两个月读完一本小说\"><a href=\"#两个月读完一本小说\" class=\"headerlink\" title=\"两个月读完一本小说\"></a>两个月读完一本小说</h5>","site":{"data":{}},"excerpt":"<p>时光荏苒…(此处略去一万字)<br>","more":"<br>时间过的有点快啊，转眼间2019年的第一个月就要结束了，马上就要回家过年了，可能有的同学已经回家或者在回家的路上了，而我还要去苦逼的上班。</p>\n<h4 id=\"新年新气象\"><a href=\"#新年新气象\" class=\"headerlink\" title=\"新年新气象\"></a>新年新气象</h4><p>去年没有给自己制定目标一切都是随遇而安，今年就给自己制定几个目标，到年底检查一下自己能完成多少。</p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 每月更新一篇博客</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 读完 你不知道的 JavaScript 全集</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 读完 JavaScript设计模式与开发实践</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 编写一个 TypeScript  的实战项目</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习一遍 Redux 源码</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习一遍 React-Router 源码</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习一遍 React 源码</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 两个月读完一本小说</li>\n</ul>\n<p>暂时就定这么多吧，年底回来检查成果。</p>\n<h4 id=\"结果检查\"><a href=\"#结果检查\" class=\"headerlink\" title=\"结果检查\"></a>结果检查</h4><h5 id=\"每月更新一篇博客\"><a href=\"#每月更新一篇博客\" class=\"headerlink\" title=\"每月更新一篇博客\"></a>每月更新一篇博客</h5><ul>\n<li>1月份博客：<a href=\"https://github.com/volcanoliuc/blog/issues/2\" target=\"_blank\" rel=\"noopener\">JavaScript函数的传参方式</a></li>\n</ul>\n<h5 id=\"两个月读完一本小说\"><a href=\"#两个月读完一本小说\" class=\"headerlink\" title=\"两个月读完一本小说\"></a>两个月读完一本小说</h5>"},{"title":"理解JavaScript作用域","date":"2018-12-19T16:00:00.000Z","_content":"#### 什么是作用域\nJavaScript 定义了一套如何存储以及查找变量的规则，这套规则就是**作用域**。\n\n作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域。JavaScript 采用的就是词法作用域。\n\n作用域主要有全局作用域、函数作用域以及 ES6 新增的块级作用域。\n<!-- more -->\n#### 全局作用域\n拥有全局作用域的是全局变量。\n\n在不用的环境中，全局变量是不同的:\n- 在浏览器环境中全局变量是 window\n- 在 Node.js 中全局变量是 golbal\n\n在浏览器 JS 中我们可以通过 window.spoce 的方式访问全局作用域下的定义的变量。\n#### 函数作用域\n> 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)\n\n在 JavaScript 中每个函数都会创建一个函数作用域。在函数之外一般是访问不到函数内定义的变量，只能在函数内部进行访问。\n```javascript\nfunction fn() {\n    var spoce = 'fn'\n    console.log(spoce); // 1\n}\nconsole.log(spoce); // 2\n```\n在上面的代码中<code>1</code> 会打印出 *fn*,\n但是执行到<code>2</code>时会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。\n##### 立即执行函数\n\n\n#### 块作用域\n在 ES6 之前，JavaScript 不存在块级作用域。\n```javascript\nif(true) {\n    var spoce = 'define spoce'\n}\nconsole.log(spoce) // 会发生什么？？？\n```\n如果是块级作用域在外面是不应该访问到 spoce 这个变量，代码就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。而实际上这段代码会打印出 *define spoce*，为什么会这样呢？\n\n用 var 声明的变量存在**变量提升**的问题。<code>var spoce = 'define spoce'</code>，分为两个部分：<code>var spoce</code> 和 <code>spoce = 'define spoce'</code>，在解析 JS 代码时会把<code>var spoce</code>提升到函数作用域的顶部，在 if 条件语句中只是对其进行了赋值操作。所以上面的代码是在函数作用域中声明了<code>spoce</code>，所以打印的是 *define spoce*。\n\n```javascript\nif(true) {\n    let spoce = 'define spoce'\n}\nconsole.log(spoce) // 又会发生什么？？？\n```\n难道这里不是打印 *define spoce* 吗?\n\n其实代码执行到这里就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em> 。\n<div align=center>\n<img width = \"150\" height = \"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/7e9adf9d26b1a18ffaf7f80129344279.gif\"/>\n</div>\n\nlet 关键字会将声明的变量隐式的绑定在所在的块作用域（通常是 {...} 内部），所以在 if {...} 这个块之外是访问不到块作用域的，所以执行到 console.log(spoce) 的时候 <code>spoce</code> 是没有声明的。\n\n使用 let 声明变量的时候还要注意的是 let 声明的变量不会变量提升，使用变量必须在声明之后才能使用，否则也是会抛出 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。\n\n在 ES6 中还有一个 const 关键字与 let 类似，只是 const 声明变量不能进行修改。\n\n#### 作用域链\n```javascript\nvar a = 10;\nfunction fn() {\n    var b = 5;\n    function fn1() {\n        var c = 1;\n        console.log('result: ', a + b + c); // result: 16\n    }\n    fn1();\n}\nfn();\n```\n<div align=center>\n<img height = \"400\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/spoce.png\"/>\n</div>\n变量<code>a</code><code>b</code><code>c</code> 都会查找当前作用域是否存在变量<code>a</code> <code>b</code> 或 <code>c</code>，如果不存在则继续查找父级作用域直至查询到全局作用域为止。这样一套变量的查找规则其实就是作用域链的作用，规定了一个变量能访问的作用域。至于为什么会这样以后有时间再细细研究（内部属性 [[Scope]] 的作用）。\n\n```javascript\nvar a = 10;\nfunction fn() {\n    var a = 5;\n    var b = 5;\n    function fn1() {\n        var c = 1;\n        console.log('result: ', a + b + c); // result: 11\n    }\n    fn1();\n}\nfn();\n```\n作用域查找会在找到第一个匹配标签的时候就结束，因此内外作用域有同名的变量的时候，会产生遮蔽效应，直接采用了内层的同名变量a。\n\n除了 let、const 之外，with 和 try/catch 也会产生块级作用域，这是这两种方法并不推荐使用，如果感兴趣可自行 google。\n\n#### 总结\n在 JavaScript 中函数作用域是我们最常使用的作用域单元，ES6 流行之后，块级作用域我们使用的也越来越多，let、const 声明的变量会添加到块级作用域中。","source":"_posts/理解JavaScript作用域.md","raw":"---\ntitle: 理解JavaScript作用域\ntag: 深入学习JS\ndate: 2018-12-20\n---\n#### 什么是作用域\nJavaScript 定义了一套如何存储以及查找变量的规则，这套规则就是**作用域**。\n\n作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域。JavaScript 采用的就是词法作用域。\n\n作用域主要有全局作用域、函数作用域以及 ES6 新增的块级作用域。\n<!-- more -->\n#### 全局作用域\n拥有全局作用域的是全局变量。\n\n在不用的环境中，全局变量是不同的:\n- 在浏览器环境中全局变量是 window\n- 在 Node.js 中全局变量是 golbal\n\n在浏览器 JS 中我们可以通过 window.spoce 的方式访问全局作用域下的定义的变量。\n#### 函数作用域\n> 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)\n\n在 JavaScript 中每个函数都会创建一个函数作用域。在函数之外一般是访问不到函数内定义的变量，只能在函数内部进行访问。\n```javascript\nfunction fn() {\n    var spoce = 'fn'\n    console.log(spoce); // 1\n}\nconsole.log(spoce); // 2\n```\n在上面的代码中<code>1</code> 会打印出 *fn*,\n但是执行到<code>2</code>时会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。\n##### 立即执行函数\n\n\n#### 块作用域\n在 ES6 之前，JavaScript 不存在块级作用域。\n```javascript\nif(true) {\n    var spoce = 'define spoce'\n}\nconsole.log(spoce) // 会发生什么？？？\n```\n如果是块级作用域在外面是不应该访问到 spoce 这个变量，代码就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。而实际上这段代码会打印出 *define spoce*，为什么会这样呢？\n\n用 var 声明的变量存在**变量提升**的问题。<code>var spoce = 'define spoce'</code>，分为两个部分：<code>var spoce</code> 和 <code>spoce = 'define spoce'</code>，在解析 JS 代码时会把<code>var spoce</code>提升到函数作用域的顶部，在 if 条件语句中只是对其进行了赋值操作。所以上面的代码是在函数作用域中声明了<code>spoce</code>，所以打印的是 *define spoce*。\n\n```javascript\nif(true) {\n    let spoce = 'define spoce'\n}\nconsole.log(spoce) // 又会发生什么？？？\n```\n难道这里不是打印 *define spoce* 吗?\n\n其实代码执行到这里就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em> 。\n<div align=center>\n<img width = \"150\" height = \"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/7e9adf9d26b1a18ffaf7f80129344279.gif\"/>\n</div>\n\nlet 关键字会将声明的变量隐式的绑定在所在的块作用域（通常是 {...} 内部），所以在 if {...} 这个块之外是访问不到块作用域的，所以执行到 console.log(spoce) 的时候 <code>spoce</code> 是没有声明的。\n\n使用 let 声明变量的时候还要注意的是 let 声明的变量不会变量提升，使用变量必须在声明之后才能使用，否则也是会抛出 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。\n\n在 ES6 中还有一个 const 关键字与 let 类似，只是 const 声明变量不能进行修改。\n\n#### 作用域链\n```javascript\nvar a = 10;\nfunction fn() {\n    var b = 5;\n    function fn1() {\n        var c = 1;\n        console.log('result: ', a + b + c); // result: 16\n    }\n    fn1();\n}\nfn();\n```\n<div align=center>\n<img height = \"400\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/spoce.png\"/>\n</div>\n变量<code>a</code><code>b</code><code>c</code> 都会查找当前作用域是否存在变量<code>a</code> <code>b</code> 或 <code>c</code>，如果不存在则继续查找父级作用域直至查询到全局作用域为止。这样一套变量的查找规则其实就是作用域链的作用，规定了一个变量能访问的作用域。至于为什么会这样以后有时间再细细研究（内部属性 [[Scope]] 的作用）。\n\n```javascript\nvar a = 10;\nfunction fn() {\n    var a = 5;\n    var b = 5;\n    function fn1() {\n        var c = 1;\n        console.log('result: ', a + b + c); // result: 11\n    }\n    fn1();\n}\nfn();\n```\n作用域查找会在找到第一个匹配标签的时候就结束，因此内外作用域有同名的变量的时候，会产生遮蔽效应，直接采用了内层的同名变量a。\n\n除了 let、const 之外，with 和 try/catch 也会产生块级作用域，这是这两种方法并不推荐使用，如果感兴趣可自行 google。\n\n#### 总结\n在 JavaScript 中函数作用域是我们最常使用的作用域单元，ES6 流行之后，块级作用域我们使用的也越来越多，let、const 声明的变量会添加到块级作用域中。","slug":"理解JavaScript作用域","published":1,"updated":"2019-03-18T02:15:35.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtfm6ltf0004ffx1yzgefrz3","content":"<h4 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h4><p>JavaScript 定义了一套如何存储以及查找变量的规则，这套规则就是<strong>作用域</strong>。</p>\n<p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域。JavaScript 采用的就是词法作用域。</p>\n<p>作用域主要有全局作用域、函数作用域以及 ES6 新增的块级作用域。<br><a id=\"more\"></a></p>\n<h4 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h4><p>拥有全局作用域的是全局变量。</p>\n<p>在不用的环境中，全局变量是不同的:</p>\n<ul>\n<li>在浏览器环境中全局变量是 window</li>\n<li>在 Node.js 中全局变量是 golbal</li>\n</ul>\n<p>在浏览器 JS 中我们可以通过 window.spoce 的方式访问全局作用域下的定义的变量。</p>\n<h4 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><blockquote>\n<p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)</p>\n</blockquote>\n<p>在 JavaScript 中每个函数都会创建一个函数作用域。在函数之外一般是访问不到函数内定义的变量，只能在函数内部进行访问。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> spoce = <span class=\"string\">'fn'</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(spoce); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spoce); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>在上面的代码中<code>1</code> 会打印出 <em>fn</em>,<br>但是执行到<code>2</code>时会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。</p>\n<h5 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h5><h4 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h4><p>在 ES6 之前，JavaScript 不存在块级作用域。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> spoce = <span class=\"string\">'define spoce'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spoce) <span class=\"comment\">// 会发生什么？？？</span></span><br></pre></td></tr></table></figure></p>\n<p>如果是块级作用域在外面是不应该访问到 spoce 这个变量，代码就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。而实际上这段代码会打印出 <em>define spoce</em>，为什么会这样呢？</p>\n<p>用 var 声明的变量存在<strong>变量提升</strong>的问题。<code>var spoce = ‘define spoce’</code>，分为两个部分：<code>var spoce</code> 和 <code>spoce = ‘define spoce’</code>，在解析 JS 代码时会把<code>var spoce</code>提升到函数作用域的顶部，在 if 条件语句中只是对其进行了赋值操作。所以上面的代码是在函数作用域中声明了<code>spoce</code>，所以打印的是 <em>define spoce</em>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> spoce = <span class=\"string\">'define spoce'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spoce) <span class=\"comment\">// 又会发生什么？？？</span></span><br></pre></td></tr></table></figure>\n<p>难道这里不是打印 <em>define spoce</em> 吗?</p>\n<p>其实代码执行到这里就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em> 。</p>\n<div align=\"center\"><br><img width=\"150\" height=\"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/7e9adf9d26b1a18ffaf7f80129344279.gif\"><br></div>\n\n<p>let 关键字会将声明的变量隐式的绑定在所在的块作用域（通常是 {…} 内部），所以在 if {…} 这个块之外是访问不到块作用域的，所以执行到 console.log(spoce) 的时候 <code>spoce</code> 是没有声明的。</p>\n<p>使用 let 声明变量的时候还要注意的是 let 声明的变量不会变量提升，使用变量必须在声明之后才能使用，否则也是会抛出 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。</p>\n<p>在 ES6 中还有一个 const 关键字与 let 类似，只是 const 声明变量不能进行修改。</p>\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'result: '</span>, a + b + c); <span class=\"comment\">// result: 16</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<p><div align=\"center\"><br><img height=\"400\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/spoce.png\"><br></div><br>变量<code>a</code><code>b</code><code>c</code> 都会查找当前作用域是否存在变量<code>a</code> <code>b</code> 或 <code>c</code>，如果不存在则继续查找父级作用域直至查询到全局作用域为止。这样一套变量的查找规则其实就是作用域链的作用，规定了一个变量能访问的作用域。至于为什么会这样以后有时间再细细研究（内部属性 [[Scope]] 的作用）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'result: '</span>, a + b + c); <span class=\"comment\">// result: 11</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<p>作用域查找会在找到第一个匹配标签的时候就结束，因此内外作用域有同名的变量的时候，会产生遮蔽效应，直接采用了内层的同名变量a。</p>\n<p>除了 let、const 之外，with 和 try/catch 也会产生块级作用域，这是这两种方法并不推荐使用，如果感兴趣可自行 google。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在 JavaScript 中函数作用域是我们最常使用的作用域单元，ES6 流行之后，块级作用域我们使用的也越来越多，let、const 声明的变量会添加到块级作用域中。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h4><p>JavaScript 定义了一套如何存储以及查找变量的规则，这套规则就是<strong>作用域</strong>。</p>\n<p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域。JavaScript 采用的就是词法作用域。</p>\n<p>作用域主要有全局作用域、函数作用域以及 ES6 新增的块级作用域。<br>","more":"</p>\n<h4 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h4><p>拥有全局作用域的是全局变量。</p>\n<p>在不用的环境中，全局变量是不同的:</p>\n<ul>\n<li>在浏览器环境中全局变量是 window</li>\n<li>在 Node.js 中全局变量是 golbal</li>\n</ul>\n<p>在浏览器 JS 中我们可以通过 window.spoce 的方式访问全局作用域下的定义的变量。</p>\n<h4 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><blockquote>\n<p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)</p>\n</blockquote>\n<p>在 JavaScript 中每个函数都会创建一个函数作用域。在函数之外一般是访问不到函数内定义的变量，只能在函数内部进行访问。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> spoce = <span class=\"string\">'fn'</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(spoce); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spoce); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>在上面的代码中<code>1</code> 会打印出 <em>fn</em>,<br>但是执行到<code>2</code>时会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。</p>\n<h5 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h5><h4 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h4><p>在 ES6 之前，JavaScript 不存在块级作用域。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> spoce = <span class=\"string\">'define spoce'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spoce) <span class=\"comment\">// 会发生什么？？？</span></span><br></pre></td></tr></table></figure></p>\n<p>如果是块级作用域在外面是不应该访问到 spoce 这个变量，代码就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。而实际上这段代码会打印出 <em>define spoce</em>，为什么会这样呢？</p>\n<p>用 var 声明的变量存在<strong>变量提升</strong>的问题。<code>var spoce = ‘define spoce’</code>，分为两个部分：<code>var spoce</code> 和 <code>spoce = ‘define spoce’</code>，在解析 JS 代码时会把<code>var spoce</code>提升到函数作用域的顶部，在 if 条件语句中只是对其进行了赋值操作。所以上面的代码是在函数作用域中声明了<code>spoce</code>，所以打印的是 <em>define spoce</em>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> spoce = <span class=\"string\">'define spoce'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spoce) <span class=\"comment\">// 又会发生什么？？？</span></span><br></pre></td></tr></table></figure>\n<p>难道这里不是打印 <em>define spoce</em> 吗?</p>\n<p>其实代码执行到这里就会报错 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em> 。</p>\n<div align=\"center\"><br><img width=\"150\" height=\"150\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/7e9adf9d26b1a18ffaf7f80129344279.gif\"><br></div>\n\n<p>let 关键字会将声明的变量隐式的绑定在所在的块作用域（通常是 {…} 内部），所以在 if {…} 这个块之外是访问不到块作用域的，所以执行到 console.log(spoce) 的时候 <code>spoce</code> 是没有声明的。</p>\n<p>使用 let 声明变量的时候还要注意的是 let 声明的变量不会变量提升，使用变量必须在声明之后才能使用，否则也是会抛出 <em style=\"color: red\">Uncaught ReferenceError: spoce is not defined</em>。</p>\n<p>在 ES6 中还有一个 const 关键字与 let 类似，只是 const 声明变量不能进行修改。</p>\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'result: '</span>, a + b + c); <span class=\"comment\">// result: 16</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<p><div align=\"center\"><br><img height=\"400\" src=\"https://raw.githubusercontent.com/volcanoliuc/blog/master/images/spoce.png\"><br></div><br>变量<code>a</code><code>b</code><code>c</code> 都会查找当前作用域是否存在变量<code>a</code> <code>b</code> 或 <code>c</code>，如果不存在则继续查找父级作用域直至查询到全局作用域为止。这样一套变量的查找规则其实就是作用域链的作用，规定了一个变量能访问的作用域。至于为什么会这样以后有时间再细细研究（内部属性 [[Scope]] 的作用）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'result: '</span>, a + b + c); <span class=\"comment\">// result: 11</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<p>作用域查找会在找到第一个匹配标签的时候就结束，因此内外作用域有同名的变量的时候，会产生遮蔽效应，直接采用了内层的同名变量a。</p>\n<p>除了 let、const 之外，with 和 try/catch 也会产生块级作用域，这是这两种方法并不推荐使用，如果感兴趣可自行 google。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在 JavaScript 中函数作用域是我们最常使用的作用域单元，ES6 流行之后，块级作用域我们使用的也越来越多，let、const 声明的变量会添加到块级作用域中。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjtfm6ltf0004ffx1yzgefrz3","tag_id":"cjtfm6ltc0002ffx12uinlbka","_id":"cjtfm6lti0006ffx1r3jjcn4l"},{"post_id":"cjtfm6lt70000ffx16h9cum2r","tag_id":"cjtfm6ltc0002ffx12uinlbka","_id":"cjtfm6lti0007ffx1kt79s73l"},{"post_id":"cjtfm6ltb0001ffx1v4oxnbz7","tag_id":"cjtfm6ltc0002ffx12uinlbka","_id":"cjtfm6lti0009ffx1a01gkuwj"},{"post_id":"cjtfm6lte0003ffx1857o1nr3","tag_id":"cjtfm6lti0008ffx1h89beu0c","_id":"cjtfm6lti000affx1tjfyzp6b"}],"Tag":[{"name":"深入学习JS","_id":"cjtfm6ltc0002ffx12uinlbka"},{"name":"随笔","_id":"cjtfm6lti0008ffx1h89beu0c"}]}}